<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rastrear Pedido</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    * {
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      background: #f5f5f5;
      overflow: hidden;
    }
    
    /* Info bar compacta no topo */
    .info-bar {
      background: #fff;
      padding: 8px 15px;
      box-shadow: 0 2px 5px rgba(0,0,0,.1);
      position: relative;
      z-index: 1000;
    }
    
    .info-item {
      margin: 4px 0;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #333;
    }
    
    .info-item strong {
      color: #667eea;
    }
    
    /* Mapa ocupando quase toda a tela */
    #map {
      height: calc(100vh - 75px);
      width: 100%;
    }
    
    /* Status de conex√£o */
    .connection-status {
      position: fixed;
      top: 85px;
      right: 10px;
      padding: 8px 15px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      z-index: 9999;
      box-shadow: 0 2px 10px rgba(0,0,0,.2);
      transition: all 0.3s ease;
    }
    
    .connection-status.connected {
      background: #4caf50;
      color: #fff;
    }
    
    .connection-status.disconnected {
      background: #f44336;
      color: #fff;
    }
    
    .connection-status.waiting {
      background: #ff9800;
      color: #fff;
    }
    
    /* Alertas */
    .alert {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: #2196F3;
      color: #fff;
      padding: 15px 25px;
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,.3);
      z-index: 9999;
      display: none;
      max-width: 90%;
      text-align: center;
      animation: slideUp 0.3s ease;
    }
    
    .alert.show {
      display: block;
    }
    
    @keyframes slideUp {
      from {
        transform: translateX(-50%) translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
      }
    }
    
    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    
    .loading-overlay.show {
      display: flex;
    }
    
    .loading-content {
      background: #fff;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
    }
    
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #667eea;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 0 auto 15px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Customiza√ß√£o do popup do Leaflet */
    .leaflet-popup-content-wrapper {
      border-radius: 10px;
      box-shadow: 0 3px 14px rgba(0,0,0,.3);
    }
    
    .leaflet-popup-content {
      margin: 10px 15px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Status de conex√£o -->
  <div class="connection-status waiting" id="connectionStatus">üü° Aguardando motorista...</div>
  
  <!-- Barra de informa√ß√µes compacta -->
  <div class="info-bar">
    <div class="info-item">
      <span>‚è±Ô∏è</span>
      <span>Tempo estimado:</span> 
      <strong id="tempoEntrega">Calculando...</strong>
    </div>
    <div class="info-item">
      <span>üìç</span>
      <span>Dist√¢ncia:</span> 
      <strong id="distancia">-</strong>
    </div>
    <div class="info-item">
      <span>üöó</span>
      <span>Status:</span> 
      <strong id="statusMotorista">Aguardando motorista...</strong>
    </div>
  </div>
  
  <!-- Mapa -->
  <div id="map"></div>

  <!-- Loading overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-content">
      <div class="spinner"></div>
      <p style="margin:0; color:#333; font-weight:500;">Calculando rota...</p>
    </div>
  </div>
  
  <!-- Alertas -->
  <div class="alert" id="alert"></div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-rotatedmarker/leaflet.rotatedMarker.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // ========================================
    // CONFIGURA√á√ÉO E INICIALIZA√á√ÉO
    // ========================================
    
    const socket = io(window.location.origin, {
      transports: ['websocket', 'polling'],
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 10,
      timeout: 10000
    });

    const apiKey = '5b3ce3597851110001cf6248461ce4f521b24420bbc67527fa68a8ab';
    
    // Offset do √¢ngulo do √≠cone do carro
    // Teste diferentes valores: 0, -90, 90, 180 at√© o carro ficar alinhado
    // Comece com 0 se o carro aponta para cima na imagem
    const ANGLE_OFFSET = 0;

    // Elementos DOM
    const connectionStatus = document.getElementById('connectionStatus');
    const alertDiv = document.getElementById('alert');
    const loadingOverlay = document.getElementById('loadingOverlay');

    // ========================================
    // DEBUG: VERIFICAR PLUGIN ROTATEDMARKER
    // ========================================
    
    console.log('üîç Verificando plugin leaflet-rotatedmarker...');
    console.log('Tipo L.Marker:', typeof L.Marker);
    console.log('Tem setRotationAngle?', typeof L.Marker.prototype.setRotationAngle);
    
    if (typeof L.Marker.prototype.setRotationAngle !== 'function') {
      console.error('‚ùå leaflet-rotatedmarker N√ÉO foi carregado corretamente!');
      alertMsg('‚ö†Ô∏è Erro ao carregar plugin de rota√ß√£o. A orienta√ß√£o do carro pode n√£o funcionar.', 5000);
    } else {
      console.log('‚úÖ Plugin leaflet-rotatedmarker carregado com sucesso!');
    }

    // ========================================
    // FUN√á√ïES UTILIT√ÅRIAS
    // ========================================
    
    function alertMsg(msg, duration = 3000) {
      alertDiv.textContent = msg;
      alertDiv.classList.add('show');
      setTimeout(() => alertDiv.classList.remove('show'), duration);
    }
    
    function calcularDistancia(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // Raio da Terra em metros
      const phi1 = lat1 * Math.PI / 180;
      const phi2 = lat2 * Math.PI / 180;
      const dPhi = (lat2 - lat1) * Math.PI / 180;
      const dLambda = (lon2 - lon1) * Math.PI / 180;
      
      const a = Math.sin(dPhi / 2) ** 2 + 
                Math.cos(phi1) * Math.cos(phi2) * 
                Math.sin(dLambda / 2) ** 2;
      
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
    
    function formatarTempo(minutos) {
      const h = Math.floor(minutos / 60);
      const m = Math.round(minutos % 60);
      return h > 0 ? `${h}h ${m}min` : `${m} min`;
    }
    
    function bearing(lat1, lon1, lat2, lon2) {
      const rad = Math.PI / 180;
      const dLon = (lon2 - lon1) * rad;
      
      const y = Math.sin(dLon) * Math.cos(lat2 * rad);
      const x = Math.cos(lat1 * rad) * Math.sin(lat2 * rad) - 
                Math.sin(lat1 * rad) * Math.cos(lat2 * rad) * Math.cos(dLon);
      
      const angle = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
      
      // Debug do √¢ngulo calculado
      console.log(`üìê Bearing calculado: ${angle.toFixed(2)}¬∞ | Com offset: ${(angle + ANGLE_OFFSET).toFixed(2)}¬∞`);
      
      return angle;
    }

    // ========================================
    // VALIDA√á√ÉO DE COORDENADAS DE DESTINO
    // ========================================
    
    let coordenadasDestino = null;
    try {
      coordenadasDestino = JSON.parse(sessionStorage.getItem('coordenadasDestino'));
      if (!coordenadasDestino?.lat || !coordenadasDestino?.lon) {
        throw new Error('Coordenadas ausentes');
      }
    } catch (error) {
      alert('Coordenadas de destino n√£o encontradas. Redirecionando...');
      window.location.href = '/endereco.html';
    }

    // ========================================
    // INICIALIZA√á√ÉO DO MAPA
    // ========================================
    
    const map = L.map('map', {
      zoomControl: true,
      attributionControl: true
    }).setView([coordenadasDestino.lat, coordenadasDestino.lon], 15);
    
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '¬© OpenStreetMap'
    }).addTo(map);

    // ========================================
    // √çCONES DOS MARCADORES
    // ========================================
    
    const destinoIcon = L.icon({
      iconUrl: 'casa.png',
      iconSize: [45, 45],
      iconAnchor: [22, 45],
      popupAnchor: [0, -45]
    });
    
    const motoristaIcon = L.icon({
      iconUrl: 'wN5QD.png',
      iconSize: [50, 50],
      iconAnchor: [25, 25],
      popupAnchor: [0, -25]
    });
    
    // Fallback icons
    const destinoIconFallback = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });
    
    const motoristaIconFallback = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });

    // ========================================
    // MARCADOR DE DESTINO
    // ========================================
    
    let marcadorDestino;
    try {
      marcadorDestino = L.marker(
        [coordenadasDestino.lat, coordenadasDestino.lon],
        { icon: destinoIcon }
      ).addTo(map).bindPopup('üè† Endere√ßo de Entrega').openPopup();
    } catch (error) {
      console.warn('Usando √≠cone fallback para destino', error);
      marcadorDestino = L.marker(
        [coordenadasDestino.lat, coordenadasDestino.lon],
        { icon: destinoIconFallback }
      ).addTo(map).bindPopup('üè† Endere√ßo de Entrega').openPopup();
    }

    // ========================================
    // VARI√ÅVEIS DE ESTADO
    // ========================================
    
    let coordenadasMotorista = null;
    let marcadorMotorista = null;
    let rota = null;
    let ultimaPosicao = null;
    let ultimaRotaCalculada = null;
    let animacaoMotorista = null;
    let totalAtualizacoes = 0;

    // ========================================
    // ANIMA√á√ÉO SUAVE DO MOTORISTA (EFEITO WAZE/UBER)
    // ========================================
    
    function animarMotorista(from, to, duracao = 800) {
      if (!marcadorMotorista) {
        console.warn('‚ö†Ô∏è Tentativa de animar marcador inexistente');
        return;
      }
      
      // Cancela anima√ß√£o anterior se existir
      if (animacaoMotorista) {
        cancelAnimationFrame(animacaoMotorista);
        animacaoMotorista = null;
      }

      const inicio = performance.now();
      const ang = bearing(from.lat, from.lon, to.lat, to.lon);
      
      console.log(`üé¨ Iniciando anima√ß√£o de (${from.lat.toFixed(6)}, ${from.lon.toFixed(6)}) para (${to.lat.toFixed(6)}, ${to.lon.toFixed(6)})`);

      function frame(agora) {
        try {
          const elapsed = agora - inicio;
          const t = Math.min(1, elapsed / duracao);
          
          // Interpola√ß√£o linear (easing)
          const lat = from.lat + (to.lat - from.lat) * t;
          const lon = from.lon + (to.lon - from.lon) * t;

          // Atualiza posi√ß√£o do marcador
          marcadorMotorista.setLatLng([lat, lon]);
          
          // Atualiza rota√ß√£o do marcador (com prote√ß√£o)
          if (typeof marcadorMotorista.setRotationAngle === 'function') {
            marcadorMotorista.setRotationAngle(ang + ANGLE_OFFSET);
          } else {
            console.warn('‚ö†Ô∏è setRotationAngle n√£o dispon√≠vel no marcador');
          }

          // Continua anima√ß√£o se n√£o terminou
          if (t < 1) {
            animacaoMotorista = requestAnimationFrame(frame);
          } else {
            animacaoMotorista = null;
            console.log('‚úÖ Anima√ß√£o conclu√≠da');
          }
        } catch (error) {
          console.error('‚ùå Erro na anima√ß√£o do motorista:', error);
          animacaoMotorista = null;
        }
      }

      animacaoMotorista = requestAnimationFrame(frame);
    }

    // ========================================
    // C√ÅLCULO DE ROTA (ORS + OSRM FALLBACK)
    // ========================================
    
    async function calcularRotaETempoORS(latInicio, lonInicio, latFim, lonFim) {
      const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${lonInicio},${latInicio}&end=${lonFim},${latFim}`;
      
      const resp = await fetch(url);
      if (!resp.ok) throw new Error('ORS HTTP ' + resp.status);
      
      const data = await resp.json();
      if (!data.features?.length) throw new Error('ORS sem rota');
      
      const seg = data.features[0].properties.segments[0];
      const coords = data.features[0].geometry.coordinates.map(([x, y]) => [y, x]);
      
      return {
        minutos: seg.duration / 60,
        distanciaKm: seg.distance / 1000,
        coords
      };
    }
    
    async function calcularRotaETempoOSRM(latInicio, lonInicio, latFim, lonFim) {
      const url = `https://router.project-osrm.org/route/v1/driving/${lonInicio},${latInicio};${lonFim},${latFim}?overview=full&geometries=geojson`;
      
      const resp = await fetch(url);
      if (!resp.ok) throw new Error('OSRM HTTP ' + resp.status);
      
      const data = await resp.json();
      if (!data.routes?.length) throw new Error('OSRM sem rota');
      
      const r = data.routes[0];
      const coords = r.geometry.coordinates.map(([x, y]) => [y, x]);
      
      return {
        minutos: r.duration / 60,
        distanciaKm: r.distance / 1000,
        coords
      };
    }

    async function calcularRotaETempo(latInicio, lonInicio, latFim, lonFim) {
      // Throttling: s√≥ recalcula se motorista se moveu mais de 50m
      if (ultimaRotaCalculada) {
        const d = calcularDistancia(
          ultimaRotaCalculada.lat,
          ultimaRotaCalculada.lon,
          latInicio,
          lonInicio
        );
        if (d < 50) {
          console.log(`‚è≠Ô∏è Pulando rec√°lculo de rota (movimento < 50m: ${d.toFixed(1)}m)`);
          return;
        }
      }
      
      try {
        loadingOverlay.classList.add('show');
        console.log('üó∫Ô∏è Calculando rota...');
        
        let resultado;
        try {
          resultado = await calcularRotaETempoORS(latInicio, lonInicio, latFim, lonFim);
          console.log('‚úÖ Rota calculada via ORS');
        } catch (error) {
          console.warn('‚ö†Ô∏è ORS falhou, tentando OSRM...', error);
          resultado = await calcularRotaETempoOSRM(latInicio, lonInicio, latFim, lonFim);
          console.log('‚úÖ Rota calculada via OSRM');
        }

        // Atualiza UI
        document.getElementById('tempoEntrega').innerText = formatarTempo(resultado.minutos);
        document.getElementById('distancia').innerText = `${resultado.distanciaKm.toFixed(1)} km`;

        // Atualiza ou cria a linha da rota
        if (rota) {
          rota.setLatLngs(resultado.coords);
        } else {
          rota = L.polyline(resultado.coords, {
            color: '#2196F3',
            weight: 5,
            opacity: 0.7,
            smoothFactor: 1
          }).addTo(map);
        }

        // Ajusta bounds do mapa para mostrar toda a rota
        const bounds = L.latLngBounds([
          [latInicio, lonInicio],
          [latFim, lonFim]
        ]);
        map.fitBounds(bounds, { padding: [50, 50] });
        
        ultimaRotaCalculada = { lat: latInicio, lon: lonInicio };
        
      } catch (error) {
        console.error('‚ùå Erro ao calcular rota:', error);
        alertMsg('‚ö†Ô∏è Erro ao calcular rota. Tentando novamente...');
      } finally {
        loadingOverlay.classList.remove('show');
      }
    }

    // ========================================
    // EVENTOS DO SOCKET
    // ========================================
    
    socket.on('connect', () => {
      console.log('‚úÖ Socket conectado');
      connectionStatus.textContent = 'üü¢ Conectado';
      connectionStatus.className = 'connection-status connected';
      alertMsg('‚úÖ Conectado ao servidor');
    });
    
    socket.on('disconnect', () => {
      console.log('‚ùå Socket desconectado');
      connectionStatus.textContent = 'üî¥ Desconectado';
      connectionStatus.className = 'connection-status disconnected';
      document.getElementById('statusMotorista').textContent = 'Desconectado do servidor';
      alertMsg('‚ùå Conex√£o perdida. Tentando reconectar...');
    });

    socket.on('atualizacaoLocalizacao', (data) => {
      totalAtualizacoes++;
      console.log(`üìç Atualiza√ß√£o #${totalAtualizacoes} recebida:`, data);
      
      const nova = { lat: data.lat, lon: data.lon };
      
      // Atualiza status de conex√£o
      connectionStatus.textContent = 'üü¢ Rastreando';
      connectionStatus.className = 'connection-status connected';

      // Calcula dist√¢ncia para o destino
      const distanciaParaDestino = calcularDistancia(
        nova.lat,
        nova.lon,
        coordenadasDestino.lat,
        coordenadasDestino.lon
      );
      
      console.log(`üìè Dist√¢ncia para destino: ${distanciaParaDestino.toFixed(1)}m`);
      
      // Atualiza status baseado na dist√¢ncia
      if (distanciaParaDestino <= 20) {
        document.getElementById('statusMotorista').textContent = 'üéâ Seu pedido chegou!';
        alertMsg('üéâ Motorista chegou ao destino!', 5000);
      } else if (distanciaParaDestino <= 100) {
        document.getElementById('statusMotorista').textContent = 'üìç Motorista muito pr√≥ximo';
      } else {
        document.getElementById('statusMotorista').textContent = 'üöó Motorista a caminho';
      }

      // Cria ou atualiza marcador do motorista
      if (marcadorMotorista) {
        // Anima movimento do marcador existente
        const from = ultimaPosicao || nova;
        animarMotorista(from, nova, 800);
      } else {
        // Cria marcador pela primeira vez
        console.log('üöó Criando marcador do motorista...');
        try {
          marcadorMotorista = L.marker([nova.lat, nova.lon], {
            icon: motoristaIcon,
            rotationAngle: 0,
            rotationOrigin: 'center'
          }).addTo(map).bindPopup('üöó Motorista');
          
          console.log('‚úÖ Marcador do motorista criado com sucesso');
          console.log('Marcador tem setRotationAngle?', typeof marcadorMotorista.setRotationAngle);
          
          alertMsg('üöó Motorista localizado!', 2500);
        } catch (error) {
          console.warn('‚ö†Ô∏è Erro ao criar marcador customizado, usando fallback', error);
          marcadorMotorista = L.marker([nova.lat, nova.lon], {
            icon: motoristaIconFallback,
            rotationAngle: 0,
            rotationOrigin: 'center'
          }).addTo(map).bindPopup('üöó Motorista');
        }
      }

      // Atualiza posi√ß√£o armazenada
      ultimaPosicao = { ...nova };
      coordenadasMotorista = nova;
      
      // Recalcula rota
      calcularRotaETempo(nova.lat, nova.lon, coordenadasDestino.lat, coordenadasDestino.lon);

      // Centraliza mapa no motorista com anima√ß√£o suave
      map.panTo([nova.lat, nova.lon], {
        animate: true,
        duration: 0.5
      });
    });

    // ========================================
    // TIMEOUT DE ESPERA
    // ========================================
    
    setTimeout(() => {
      if (!coordenadasMotorista) {
        console.log('‚è∞ Timeout: ainda aguardando motorista ap√≥s 30s');
        alertMsg('‚ö†Ô∏è Aguardando motorista iniciar a entrega...', 5000);
      }
    }, 30000);

    // ========================================
    // LOG DE DEBUG INICIAL
    // ========================================
    
    console.log('üó∫Ô∏è Mapa inicializado');
    console.log('üìç Destino:', coordenadasDestino);
    console.log('üîÑ Offset de √¢ngulo do √≠cone:', ANGLE_OFFSET);
    console.log('üí° Se o carro estiver de lado, ajuste ANGLE_OFFSET para: 0, -90, 90 ou 180');
  </script>
</body>
</html>
